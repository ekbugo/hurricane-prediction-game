<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hurricane Track Predictor</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .app-container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #1e3a8a 0%, #3b82f6 100%);
            color: white;
            padding: 24px;
            text-align: center;
        }
        
        .hurricane-name {
            font-size: 32px;
            font-weight: 700;
            margin: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .content {
            display: flex;
            min-height: 600px;
        }
        
        .sidebar {
            width: 250px;
            padding: 24px;
            background: #f8fafc;
            border-right: 1px solid #e2e8f0;
        }
        
        .sidebar h3 {
            font-size: 16px;
            color: #334155;
            margin-bottom: 16px;
            font-weight: 600;
        }
        
        .layer-control {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: white;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .layer-control:hover {
            border-color: #3b82f6;
            background: #eff6ff;
        }
        
        .layer-control input[type="radio"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .layer-control label {
            cursor: pointer;
            font-size: 14px;
            color: #475569;
            font-weight: 500;
        }
        
        .map-container {
            flex: 1;
            position: relative;
        }
        
        #map {
            width: 100%;
            height: 100%;
        }
        
        .predictions-sidebar {
            width: 300px;
            padding: 24px;
            background: #f8fafc;
            border-left: 1px solid #e2e8f0;
            overflow-y: auto;
        }
        
        .predictions-sidebar h3 {
            font-size: 16px;
            color: #334155;
            margin-bottom: 16px;
            font-weight: 600;
        }
        
        .prediction-group {
            margin-bottom: 16px;
        }
        
        .prediction-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: #3b82f6;
            color: white;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            transition: background 0.2s;
            font-weight: 600;
        }
        
        .prediction-header:hover {
            background: #2563eb;
        }
        
        .prediction-header .chevron {
            transition: transform 0.2s;
        }
        
        .prediction-header.open .chevron {
            transform: rotate(180deg);
        }
        
        .prediction-content {
            border: 2px solid #3b82f6;
            border-top: none;
            border-radius: 0 0 8px 8px;
            padding: 16px;
            background: white;
        }
        
        .prediction-content.closed {
            display: none;
        }
        
        .input-group {
            margin-bottom: 12px;
        }
        
        .input-group label {
            display: block;
            font-size: 12px;
            color: #64748b;
            margin-bottom: 4px;
            font-weight: 500;
        }
        
        .input-group input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        
        .input-group input:focus {
            outline: none;
            border-color: #3b82f6;
        }
        
        .starting-position {
            background: #fef3c7;
            border: 2px solid #fbbf24;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 24px;
        }
        
        .starting-position h4 {
            font-size: 14px;
            color: #92400e;
            margin-bottom: 12px;
            font-weight: 600;
        }
        
        .starting-position p {
            font-size: 13px;
            color: #78350f;
            margin-bottom: 4px;
        }
        
        .starting-position strong {
            color: #92400e;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function HurricaneTrackerApp() {
            const mapRef = useRef(null);
            const mapInstanceRef = useRef(null);
            const markersRef = useRef([]);
            const polylineRef = useRef(null);
            const steeringLayerRef = useRef(null);
            
            const [showSteeringCurrents, setShowSteeringCurrents] = useState(false);
            const [predictions, setPredictions] = useState({
                12: { lat: '', lon: '', open: false },
                24: { lat: '', lon: '', open: false },
                36: { lat: '', lon: '', open: false },
                48: { lat: '', lon: '', open: false }
            });
            
            // Sample hurricane data - you can modify this
            const hurricaneData = {
                name: "Hurricane Maria",
                startLat: 25.5,
                startLon: -75.2
            };

            // Initialize map
            useEffect(() => {
                if (!mapInstanceRef.current) {
                    const map = L.map(mapRef.current).setView(
                        [hurricaneData.startLat, hurricaneData.startLon], 
                        6
                    );

                    // Add base map tile layer
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '© OpenStreetMap contributors',
                        maxZoom: 18
                    }).addTo(map);

                    mapInstanceRef.current = map;

                    // Add starting position marker
                    const startMarker = L.marker([hurricaneData.startLat, hurricaneData.startLon], {
                        icon: L.divIcon({
                            className: 'custom-marker',
                            html: '<div style="background: red; width: 16px; height: 16px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>',
                            iconSize: [22, 22],
                            iconAnchor: [11, 11]
                        })
                    }).addTo(map);
                    
                    startMarker.bindPopup(`<b>Starting Position</b><br>Lat: ${hurricaneData.startLat}<br>Lon: ${hurricaneData.startLon}`);
                    markersRef.current.push(startMarker);
                }
            }, []);

            // Toggle steering currents layer
            useEffect(() => {
                const map = mapInstanceRef.current;
                if (!map) return;

                if (showSteeringCurrents) {
                    // Add a simple overlay to represent steering currents
                    // In a real app, this would be actual meteorological data
                    steeringLayerRef.current = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        opacity: 0.3,
                        attribution: 'Steering Currents (Demo)'
                    }).addTo(map);
                } else {
                    if (steeringLayerRef.current) {
                        map.removeLayer(steeringLayerRef.current);
                        steeringLayerRef.current = null;
                    }
                }
            }, [showSteeringCurrents]);

            // Update map with predictions
            useEffect(() => {
                const map = mapInstanceRef.current;
                if (!map) return;

                // Clear previous prediction markers (keep starting marker)
                while (markersRef.current.length > 1) {
                    const marker = markersRef.current.pop();
                    map.removeLayer(marker);
                }

                // Clear previous polyline
                if (polylineRef.current) {
                    map.removeLayer(polylineRef.current);
                    polylineRef.current = null;
                }

                // Collect all valid prediction points
                const points = [[hurricaneData.startLat, hurricaneData.startLon]];
                
                [12, 24, 36, 48].forEach(hours => {
                    const pred = predictions[hours];
                    if (pred.lat && pred.lon) {
                        const lat = parseFloat(pred.lat);
                        const lon = parseFloat(pred.lon);
                        
                        if (!isNaN(lat) && !isNaN(lon)) {
                            points.push([lat, lon]);
                            
                            // Add marker for this prediction
                            const marker = L.marker([lat, lon], {
                                icon: L.divIcon({
                                    className: 'custom-marker',
                                    html: `<div style="background: #3b82f6; width: 14px; height: 14px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);"></div>`,
                                    iconSize: [18, 18],
                                    iconAnchor: [9, 9]
                                })
                            }).addTo(map);
                            
                            marker.bindPopup(`<b>${hours} Hour Prediction</b><br>Lat: ${lat}<br>Lon: ${lon}`);
                            markersRef.current.push(marker);
                        }
                    }
                });

                // Draw dashed line connecting all points
                if (points.length > 1) {
                    polylineRef.current = L.polyline(points, {
                        color: '#3b82f6',
                        weight: 3,
                        dashArray: '10, 10',
                        opacity: 0.8
                    }).addTo(map);
                }
            }, [predictions]);

            const handlePredictionChange = (hours, field, value) => {
                setPredictions(prev => ({
                    ...prev,
                    [hours]: {
                        ...prev[hours],
                        [field]: value
                    }
                }));
            };

            const togglePrediction = (hours) => {
                setPredictions(prev => ({
                    ...prev,
                    [hours]: {
                        ...prev[hours],
                        open: !prev[hours].open
                    }
                }));
            };

            return (
                <div className="app-container">
                    <div className="header">
                        <h1 className="hurricane-name">{hurricaneData.name}</h1>
                    </div>
                    
                    <div className="content">
                        <div className="sidebar">
                            <h3>Map Layers</h3>
                            <div className="layer-control">
                                <input 
                                    type="radio" 
                                    id="steering-currents"
                                    checked={showSteeringCurrents}
                                    onChange={(e) => setShowSteeringCurrents(e.target.checked)}
                                />
                                <label htmlFor="steering-currents">Steering Currents</label>
                            </div>
                        </div>
                        
                        <div className="map-container">
                            <div id="map" ref={mapRef}></div>
                        </div>
                        
                        <div className="predictions-sidebar">
                            <h3>Your Predictions</h3>
                            
                            <div className="starting-position">
                                <h4>Starting Position</h4>
                                <p><strong>Latitude:</strong> {hurricaneData.startLat}°</p>
                                <p><strong>Longitude:</strong> {hurricaneData.startLon}°</p>
                            </div>
                            
                            {[12, 24, 36, 48].map(hours => (
                                <div key={hours} className="prediction-group">
                                    <div 
                                        className={`prediction-header ${predictions[hours].open ? 'open' : ''}`}
                                        onClick={() => togglePrediction(hours)}
                                    >
                                        <span>{hours} Hour Forecast</span>
                                        <span className="chevron">▼</span>
                                    </div>
                                    <div className={`prediction-content ${predictions[hours].open ? '' : 'closed'}`}>
                                        <div className="input-group">
                                            <label>Latitude</label>
                                            <input 
                                                type="number" 
                                                step="0.1"
                                                placeholder="e.g., 26.5"
                                                value={predictions[hours].lat}
                                                onChange={(e) => handlePredictionChange(hours, 'lat', e.target.value)}
                                            />
                                        </div>
                                        <div className="input-group">
                                            <label>Longitude</label>
                                            <input 
                                                type="number" 
                                                step="0.1"
                                                placeholder="e.g., -74.2"
                                                value={predictions[hours].lon}
                                                onChange={(e) => handlePredictionChange(hours, 'lon', e.target.value)}
                                            />
                                        </div>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        ReactDOM.render(<HurricaneTrackerApp />, document.getElementById('root'));
    </script>
</body>
</html>
