<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hurricane Prediction Game - 6hr Timeframes</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            margin: 0;
            padding: 0;
        }
        #map {
            height: 500px;
            border-radius: 0.5rem;
            width: 100%;
        }
        .pulse {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 to-blue-100 min-h-screen">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect } = React;

        // API Configuration
        const API_BASE_URL = 'https://hurricane-prediction-game-production.up.railway.app/api';

        function HurricaneGameApp() {
            const [gameState, setGameState] = useState(null);
            const [userPredictions, setUserPredictions] = useState([]);
            const [username, setUsername] = useState('');
            const [currentPrediction, setCurrentPrediction] = useState({
                lat: '',
                lon: '',
                windSpeed: '',
                pressure: ''
            });
            const [view, setView] = useState('predict');
            const [map, setMap] = useState(null);
            const [loading, setLoading] = useState(true);
            const [leaderboard, setLeaderboard] = useState([]);
            const [participants, setParticipants] = useState([]);

            // Fetch game state
            useEffect(() => {
                const fetchGameState = async () => {
                    try {
                        const response = await fetch(`${API_BASE_URL}/game/state`);
                        const data = await response.json();
                        setGameState(data);
                        setLoading(false);
                    } catch (error) {
                        console.error('Error fetching game state:', error);
                        setLoading(false);
                    }
                };
                
                fetchGameState();
                const interval = setInterval(fetchGameState, 30000); // Refresh every 30s
                return () => clearInterval(interval);
            }, []);

            // Fetch user predictions
            useEffect(() => {
                if (!username || !gameState) return;
                
                const fetchPredictions = async () => {
                    try {
                        const response = await fetch(`${API_BASE_URL}/predictions/user/${username}`);
                        const data = await response.json();
                        setUserPredictions(data.predictions || []);
                    } catch (error) {
                        console.error('Error fetching predictions:', error);
                    }
                };
                
                fetchPredictions();
            }, [username, gameState]);

            // Fetch leaderboard
            useEffect(() => {
                if (!gameState || view !== 'leaderboard') return;
                
                const fetchLeaderboardData = async () => {
                    try {
                        // Fetch scored leaderboard
                        const lbResponse = await fetch(`${API_BASE_URL}/leaderboard/${gameState.storm.id}`);
                        const lbData = await lbResponse.json();
                        setLeaderboard(lbData.leaderboard || []);
                        
                        // Fetch all participants
                        const partResponse = await fetch(`${API_BASE_URL}/participants/${gameState.storm.id}`);
                        const partData = await partResponse.json();
                        setParticipants(partData.participants || []);
                    } catch (error) {
                        console.error('Error fetching leaderboard:', error);
                    }
                };
                
                fetchLeaderboardData();
            }, [gameState, view]);

            // Initialize map
            useEffect(() => {
                if (map || !gameState) return;
                
                // Wait for DOM element to be available
                const mapElement = document.getElementById('map');
                if (!mapElement || typeof L === 'undefined') return;
                
                try {
                    const newMap = L.map('map').setView([25.0, -80.0], 5);
                    
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '¬© OpenStreetMap contributors'
                    }).addTo(newMap);

                    setMap(newMap);
                } catch (error) {
                    console.error('Error initializing map:', error);
                }
            }, [map, gameState]);

            // Update map with storm track
            useEffect(() => {
                if (!map || !gameState || !gameState.timeframes) return;

                // Clear existing layers
                map.eachLayer((layer) => {
                    if (!(layer instanceof L.TileLayer)) {
                        map.removeLayer(layer);
                    }
                });

                const getCategoryColor = (cat) => {
                    const colors = {
                        0: '#6B7280',
                        1: '#FBBF24',
                        2: '#F59E0B',
                        3: '#EF4444',
                        4: '#DC2626',
                        5: '#7C3AED'
                    };
                    return colors[cat] || '#6B7280';
                };

                // Determine which timeframes have been "released" (past timeframes)
                const now = new Date();
                const gameStart = new Date(gameState.storm.gameStart);
                const hoursSinceStart = (now - gameStart) / (1000 * 60 * 60);
                
                // Only show timeframes that have passed
                const releasedTimeframes = gameState.timeframes.filter(tf => {
                    if (tf.type === 'base') return true; // Always show base
                    if (tf.timeframe === '0600') return hoursSinceStart >= 6;
                    if (tf.timeframe === '1200') return hoursSinceStart >= 12;
                    if (tf.timeframe === '1800') return hoursSinceStart >= 18;
                    if (tf.timeframe === '0000') return hoursSinceStart >= 24;
                    return false;
                });

                // Draw storm track (only released points)
                const releasedPoints = releasedTimeframes.map(tf => [tf.lat, tf.lon]);
                if (releasedPoints.length > 1) {
                    L.polyline(releasedPoints, { color: '#4B5563', weight: 4, opacity: 0.8 })
                        .addTo(map);
                }

                // Plot each released timeframe
                releasedTimeframes.forEach((tf) => {
                    const color = getCategoryColor(tf.category);
                    const icon = L.divIcon({
                        className: 'custom-icon',
                        html: `<div style="background-color: ${color}; width: ${tf.type === 'base' ? 24 : 16}px; height: ${tf.type === 'base' ? 24 : 16}px; border-radius: 50%; border: 3px solid white;"></div>`,
                        iconSize: [tf.type === 'base' ? 24 : 16, tf.type === 'base' ? 24 : 16]
                    });
                    
                    L.marker([tf.lat, tf.lon], { icon }).addTo(map)
                        .bindPopup(`<strong>${tf.timeframe} ${tf.type === 'base' ? '(Base)' : '(Actual)'}</strong><br>Cat ${tf.category}<br>${tf.windSpeed} mph<br>${tf.pressure} mb`);
                });

                // Draw user's predictions (green) with connecting line
                if (userPredictions && userPredictions.length > 0) {
                    const predictionPoints = userPredictions.map(pred => [pred.predicted_lat, pred.predicted_lon]);
                    
                    // Draw line connecting predictions
                    if (predictionPoints.length > 1) {
                        L.polyline(predictionPoints, { 
                            color: '#10B981', 
                            weight: 4, 
                            opacity: 0.9, 
                            dashArray: '10, 10' 
                        }).addTo(map);
                    }
                    
                    // Draw individual prediction points
                    userPredictions.forEach(pred => {
                        const icon = L.divIcon({
                            className: 'custom-icon',
                            html: `<div style="background-color: #10B981; width: 18px; height: 18px; border-radius: 50%; border: 3px solid white; box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);"></div>`,
                            iconSize: [18, 18]
                        });
                        
                        L.marker([pred.predicted_lat, pred.predicted_lon], { icon }).addTo(map)
                            .bindPopup(`<strong>Your ${pred.timeframe} Prediction</strong><br>${pred.predicted_wind_speed} mph<br>${pred.predicted_pressure} mb`);
                    });
                }

                // Fit map to show all points (only once, with valid points)
                const allMapPoints = [...releasedPoints];
                if (userPredictions && userPredictions.length > 0) {
                    userPredictions.forEach(pred => {
                        if (pred.predicted_lat && pred.predicted_lon) {
                            allMapPoints.push([pred.predicted_lat, pred.predicted_lon]);
                        }
                    });
                }
                
                if (allMapPoints.length > 0) {
                    try {
                        map.fitBounds(allMapPoints, { padding: [50, 50], maxZoom: 8 });
                    } catch (error) {
                        console.log('Could not fit bounds:', error);
                    }
                }
            }, [map, gameState, userPredictions]);

            const handlePredictionChange = (field, value) => {
                setCurrentPrediction({
                    ...currentPrediction,
                    [field]: value
                });
            };

            const handleSubmit = async (e) => {
                e.preventDefault();
                
                if (!username) {
                    alert('Please enter your username');
                    return;
                }

                if (!currentPrediction.lat || !currentPrediction.lon || !currentPrediction.windSpeed || !currentPrediction.pressure) {
                    alert('Please fill all prediction fields');
                    return;
                }

                try {
                    const response = await fetch(`${API_BASE_URL}/predictions`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            username: username,
                            stormId: gameState.storm.id,
                            timeframe: gameState.activeTimeframe,
                            lat: parseFloat(currentPrediction.lat),
                            lon: parseFloat(currentPrediction.lon),
                            windSpeed: parseInt(currentPrediction.windSpeed),
                            pressure: parseInt(currentPrediction.pressure)
                        })
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.error || 'Failed to submit');
                    }

                    alert('Prediction submitted successfully!');
                    
                    // Reset form
                    setCurrentPrediction({ lat: '', lon: '', windSpeed: '', pressure: '' });
                    
                    // Refresh predictions
                    const predResponse = await fetch(`${API_BASE_URL}/predictions/user/${username}`);
                    const predData = await predResponse.json();
                    setUserPredictions(predData.predictions || []);
                    
                } catch (error) {
                    alert(`Error: ${error.message}`);
                }
            };

            const getTimeframeStatus = (timeframe) => {
                if (!gameState) return 'locked';
                
                const userPred = userPredictions.find(p => p.timeframe === timeframe);
                if (userPred) return 'submitted';
                
                if (timeframe === gameState.activeTimeframe) return 'active';
                
                return 'locked';
            };

            const formatTimeUntilUnlock = (hours) => {
                const h = Math.floor(hours);
                const m = Math.floor((hours - h) * 60);
                return `${h}h ${m}m`;
            };

            if (loading) {
                return (
                    <div className="flex items-center justify-center min-h-screen">
                        <div className="text-2xl">Loading game...</div>
                    </div>
                );
            }

            if (!gameState) {
                return (
                    <div className="flex items-center justify-center min-h-screen">
                        <div className="text-2xl text-red-600">No active storm</div>
                    </div>
                );
            }

            return (
                <div className="container mx-auto px-4 py-8 max-w-7xl">
                    {/* Header */}
                    <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                        <div className="flex items-center justify-between">
                            <div>
                                <h1 className="text-4xl font-bold text-gray-800">üåÄ {gameState.storm.name}</h1>
                                <p className="text-gray-600">24-Hour Prediction Challenge</p>
                                <p className="text-sm text-gray-500 mt-1">
                                    Current Time (UTC): {new Date().toUTCString()}
                                </p>
                            </div>
                            <div className="flex gap-4">
                                <button
                                    onClick={() => setView('predict')}
                                    className={`px-6 py-3 rounded-lg font-bold transition-all ${view === 'predict' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                >
                                    Predict
                                </button>
                                <button
                                    onClick={() => setView('leaderboard')}
                                    className={`px-6 py-3 rounded-lg font-bold transition-all ${view === 'leaderboard' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                >
                                    Leaderboard
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Map */}
                    <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                        <h2 className="text-xl font-bold text-gray-800 mb-4">Storm Track</h2>
                        <div id="map"></div>
                    </div>

                    {/* Main Content */}
                    {view === 'predict' ? (
                        <div key="predict-view" className="bg-white rounded-lg shadow-lg p-6">
                            <h2 className="text-2xl font-bold text-gray-800 mb-6">Submit Your Prediction</h2>
                            
                            {/* Username */}
                            <div className="mb-6">
                                <label className="block text-sm font-bold text-gray-700 mb-2">Username *</label>
                                <input
                                    type="text"
                                    value={username}
                                    onChange={(e) => setUsername(e.target.value)}
                                    className="w-full px-4 py-3 border border-gray-300 rounded-lg"
                                    placeholder="Enter your username"
                                />
                            </div>

                            {/* Info Box */}
                            <div className="bg-green-50 border-l-4 border-green-500 p-4 mb-6">
                                <p className="text-sm text-green-800">
                                    <strong>üìç Enter predictions for the next available timeframe.</strong><br/>
                                    Your predictions will appear as green points on the map with a dashed line connecting them.
                                </p>
                            </div>

                            {/* Timeframes */}
                            <div className="space-y-4">
                                {gameState.timeframes.map((tf, index) => {
                                    if (tf.type === 'base') {
                                        // Base data - always shown, read-only
                                        return (
                                            <div key={tf.timeframe} className="bg-gray-100 rounded-lg p-4">
                                                <div className="flex items-center justify-between mb-3">
                                                    <h3 className="font-bold text-gray-800">{tf.timeframe} Base</h3>
                                                </div>
                                                <div className="grid grid-cols-4 gap-4">
                                                    <div>
                                                        <label className="block text-xs font-medium text-gray-600 mb-1">Latitude</label>
                                                        <input
                                                            type="text"
                                                            value={tf.lat}
                                                            disabled
                                                            className="w-full px-3 py-2 bg-white border border-gray-300 rounded text-gray-500"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs font-medium text-gray-600 mb-1">Longitude</label>
                                                        <input
                                                            type="text"
                                                            value={tf.lon}
                                                            disabled
                                                            className="w-full px-3 py-2 bg-white border border-gray-300 rounded text-gray-500"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs font-medium text-gray-600 mb-1">Maximum Winds</label>
                                                        <input
                                                            type="text"
                                                            value={tf.windSpeed}
                                                            disabled
                                                            className="w-full px-3 py-2 bg-white border border-gray-300 rounded text-gray-500"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label className="block text-xs font-medium text-gray-600 mb-1">Pressure</label>
                                                        <input
                                                            type="text"
                                                            value={tf.pressure}
                                                            disabled
                                                            className="w-full px-3 py-2 bg-white border border-gray-300 rounded text-gray-500"
                                                        />
                                                    </div>
                                                </div>
                                            </div>
                                        );
                                    }

                                    const status = getTimeframeStatus(tf.timeframe);
                                    const isActive = status === 'active';
                                    const isSubmitted = status === 'submitted';
                                    const isLocked = status === 'locked';

                                    // Determine if this is a past or future locked timeframe
                                    const now = new Date();
                                    const gameStart = new Date(gameState.storm.gameStart);
                                    const hoursSinceStart = (now - gameStart) / (1000 * 60 * 60);
                                    
                                    let isPastTimeframe = false;
                                    let hoursUntilUnlock = 0;
                                    
                                    if (tf.timeframe === '0600') {
                                        isPastTimeframe = hoursSinceStart >= 6;
                                        hoursUntilUnlock = 6 - hoursSinceStart;
                                    } else if (tf.timeframe === '1200') {
                                        isPastTimeframe = hoursSinceStart >= 12;
                                        hoursUntilUnlock = 12 - hoursSinceStart;
                                    } else if (tf.timeframe === '1800') {
                                        isPastTimeframe = hoursSinceStart >= 18;
                                        hoursUntilUnlock = 18 - hoursSinceStart;
                                    } else if (tf.timeframe === '0000') {
                                        isPastTimeframe = hoursSinceStart >= 24;
                                        hoursUntilUnlock = 24 - hoursSinceStart;
                                    }

                                    const bgColor = isActive ? 'bg-green-50' : 'bg-gray-100';
                                    const borderColor = isActive ? 'border-green-500' : 'border-gray-300';

                                    return (
                                        <div key={tf.timeframe} className={`rounded-lg p-4 border-2 ${bgColor} ${borderColor}`}>
                                            <div className="flex items-center justify-between mb-3">
                                                <h3 className="font-bold text-gray-800">{tf.timeframe} Prediction</h3>
                                                {isLocked && !isSubmitted && !isPastTimeframe && hoursUntilUnlock > 0 && (
                                                    <span className="text-sm bg-gray-700 text-white px-3 py-1 rounded">
                                                        Opens in: {formatTimeUntilUnlock(hoursUntilUnlock)}
                                                    </span>
                                                )}
                                                {isLocked && !isSubmitted && isPastTimeframe && (
                                                    <span className="text-sm bg-red-600 text-white px-3 py-1 rounded">
                                                        ‚è±Ô∏è Closed - Missed
                                                    </span>
                                                )}
                                                {isSubmitted && (
                                                    <span className="text-sm bg-blue-600 text-white px-3 py-1 rounded">
                                                        ‚úì Submitted
                                                    </span>
                                                )}
                                            </div>
                                            <div className="grid grid-cols-4 gap-4">
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-700 mb-1">Latitude</label>
                                                    <input
                                                        type="number"
                                                        step="0.1"
                                                        value={isActive ? currentPrediction.lat : (isSubmitted ? userPredictions.find(p => p.timeframe === tf.timeframe)?.predicted_lat : '')}
                                                        onChange={(e) => isActive && handlePredictionChange('lat', e.target.value)}
                                                        disabled={!isActive}
                                                        className="w-full px-3 py-2 border border-gray-300 rounded"
                                                        placeholder="e.g., 26.5"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-700 mb-1">Longitude</label>
                                                    <input
                                                        type="number"
                                                        step="0.1"
                                                        value={isActive ? currentPrediction.lon : (isSubmitted ? userPredictions.find(p => p.timeframe === tf.timeframe)?.predicted_lon : '')}
                                                        onChange={(e) => isActive && handlePredictionChange('lon', e.target.value)}
                                                        disabled={!isActive}
                                                        className="w-full px-3 py-2 border border-gray-300 rounded"
                                                        placeholder="e.g., -82.0"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-700 mb-1">Maximum Winds</label>
                                                    <input
                                                        type="number"
                                                        value={isActive ? currentPrediction.windSpeed : (isSubmitted ? userPredictions.find(p => p.timeframe === tf.timeframe)?.predicted_wind_speed : '')}
                                                        onChange={(e) => isActive && handlePredictionChange('windSpeed', e.target.value)}
                                                        disabled={!isActive}
                                                        className="w-full px-3 py-2 border border-gray-300 rounded"
                                                        placeholder="e.g., 135"
                                                    />
                                                </div>
                                                <div>
                                                    <label className="block text-xs font-medium text-gray-700 mb-1">Pressure</label>
                                                    <input
                                                        type="number"
                                                        value={isActive ? currentPrediction.pressure : (isSubmitted ? userPredictions.find(p => p.timeframe === tf.timeframe)?.predicted_pressure : '')}
                                                        onChange={(e) => isActive && handlePredictionChange('pressure', e.target.value)}
                                                        disabled={!isActive}
                                                        className="w-full px-3 py-2 border border-gray-300 rounded"
                                                        placeholder="e.g., 945"
                                                    />
                                                </div>
                                            </div>
                                            {isActive && (
                                                <div className="mt-4">
                                                    <button
                                                        onClick={handleSubmit}
                                                        className="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg transition-all"
                                                    >
                                                        Submit Prediction
                                                    </button>
                                                </div>
                                            )}
                                        </div>
                                    );
                                })}
                            </div>
                        </div>
                    ) : (
                        <div key="leaderboard-view" className="bg-white rounded-lg shadow-lg p-6">
                            <h2 className="text-2xl font-bold text-gray-800 mb-6">üèÜ Leaderboard - {gameState.storm.name}</h2>
                            
                            {/* Participants List (always show if anyone has submitted) */}
                            {participants.length > 0 && (
                                <div className="mb-6 p-4 bg-blue-50 rounded-lg">
                                    <h3 className="font-bold text-blue-900 mb-3">
                                        üë• {participants.length} Participant{participants.length !== 1 ? 's' : ''} Competing
                                    </h3>
                                    <div className="flex flex-wrap gap-2">
                                        {participants.map(p => (
                                            <span key={p.username} className="bg-white px-3 py-1 rounded-full text-sm text-gray-700 border border-blue-200">
                                                {p.username} ({p.predictions_count})
                                            </span>
                                        ))}
                                    </div>
                                    <p className="text-xs text-blue-700 mt-2">
                                        Numbers show how many predictions each user has submitted
                                    </p>
                                </div>
                            )}
                            
                            {/* Scored Leaderboard */}
                            <h3 className="font-bold text-gray-800 mb-3 text-lg">üìä Current Scores</h3>
                            {leaderboard.length === 0 ? (
                                <div className="text-center py-12">
                                    <div className="text-6xl mb-4">‚è≥</div>
                                    <p className="text-gray-600 text-lg font-semibold">No scores yet!</p>
                                    <p className="text-gray-500 text-sm mt-2">
                                        Scores will appear once timeframes close and predictions are scored.
                                    </p>
                                    <p className="text-gray-500 text-sm mt-1">
                                        Keep predicting - leaderboard updates automatically!
                                    </p>
                                </div>
                            ) : (
                                <div className="space-y-3">
                                    {leaderboard.map((entry, index) => (
                                        <div
                                            key={entry.username}
                                            className="flex items-center gap-4 p-4 rounded-lg bg-gray-50 hover:bg-gray-100 transition-all"
                                        >
                                            <div className="text-3xl font-bold w-12 text-center">
                                                {index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `#${index + 1}`}
                                            </div>
                                            <div className="flex-1">
                                                <div className="font-bold text-lg">{entry.username}</div>
                                                <div className="text-sm text-gray-600">
                                                    {entry.predictions_count} prediction{entry.predictions_count !== 1 ? 's' : ''} submitted
                                                    {entry.total_score > 0 && ` ‚Ä¢ Avg: ${Math.round(entry.total_score / entry.predictions_count)} pts/prediction`}
                                                </div>
                                            </div>
                                            <div className="text-right">
                                                <div className="text-2xl font-bold text-blue-600">
                                                    {entry.total_score || 0}
                                                </div>
                                                <div className="text-sm text-gray-600">
                                                    {entry.total_score > 0 ? 'points' : 'pending'}
                                                </div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}
                            
                            {/* Scoring Legend */}
                            <div className="mt-8 p-4 bg-blue-50 rounded-lg">
                                <h3 className="font-bold text-blue-900 mb-2">üìä Scoring System</h3>
                                <div className="text-sm text-blue-800 space-y-1">
                                    <p><strong>Track Score (0-1000 pts):</strong> Based on distance error from actual position</p>
                                    <p><strong>Intensity Score (0-1000 pts):</strong> Based on wind speed + pressure accuracy</p>
                                    <p><strong>Total per timeframe:</strong> 0-2000 pts</p>
                                    <p><strong>Total per storm:</strong> 0-8000 pts (4 timeframes)</p>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        ReactDOM.render(<HurricaneGameApp />, document.getElementById('root'));
    </script>
</body>
</html>
